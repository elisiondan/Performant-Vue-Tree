(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{375:function(t,a,e){"use strict";e.r(a);var s=e(41),n=Object(s.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"node-evaluators"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#node-evaluators"}},[t._v("#")]),t._v(" Node evaluators")]),t._v(" "),e("p",[t._v("Every interaction that requires to traverse through the whole tree is quite resource expensive. Therefore, the "),e("em",[t._v("Performant Vue tree")]),t._v(" uses service workers in the background to do the heavy lifting, thus assures that the UI thread is not blocked.")]),t._v(" "),e("p",[t._v("Whenever you need perform an action that requires the full tree traversal while maintaining the state (open/closed, highlights) etc. or do not wish to use service workers from scratch by yourself, you may use "),e("code",[t._v("node evaluators")]),t._v(".")]),t._v(" "),e("h2",{attrs:{id:"creating-a-node-evaluator"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#creating-a-node-evaluator"}},[t._v("#")]),t._v(" Creating a node evaluator")]),t._v(" "),e("p",[t._v("An evaluator should be an object that contains a method with the following signature:")]),t._v(" "),e("div",{staticClass:"language-javascript extra-class"},[e("pre",{pre:!0,attrs:{class:"language-javascript"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" IProcessedTreeNode "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("'vue-performant-tree/src/models/tree-node'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// TBD")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("handleNode")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("node"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" IProcessedTreeNode"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" payload"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" any"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v("\n")])])]),e("p",[t._v("In short, the "),e("code",[t._v("handleNode")]),t._v(" method receives the given node and any kind of payload that is sent by the "),e("a",{attrs:{href:"/advanced/tree-traversal"}},[t._v("treeObserver")]),t._v(". Beware that the payload may contain data targeted for at other evaluators, so it is "),e("strong",[t._v("responsibility of each evaluator to check whether the data are for them")]),t._v(".")]),t._v(" "),e("p",[t._v("An exemplary implementation of an evaluator that expands each node with children could look like this.")]),t._v(" "),e("div",{staticClass:"language-javascript extra-class"},[e("pre",{pre:!0,attrs:{class:"language-javascript"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// expand-all-evaluator.ts")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" INodeEvaluator "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("'performant-vue-tree/dist/models/node-evaluator'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" IProcessedTreeNode "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("'performant-vue-tree/dist/models/tree-node'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("interface")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("IExpandAllOptions")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    expandAll"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" boolean"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" expandAllEvaluator"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" INodeEvaluator "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("handleNode")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("node"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" IProcessedTreeNode"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" payload"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" IExpandAllOptions"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("payload"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("expandAll"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      node"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("__state "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("'open'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n      node"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("__visible "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("export")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("default")]),t._v(" expandAllEvaluator"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n")])])]),e("p",[t._v("Do note the we check whether the "),e("code",[t._v("expandAll")]),t._v(" on "),e("em",[t._v("payload")]),t._v(" argument is "),e("strong",[t._v("true")]),t._v(" (it would have been false if undefined). When it is, setting the type of payload enabled suggestions and type checking later in the code. Naturally, this is not precise, because we do not know upfront it's truly the given type. Ideally, it should be set to unknown and only then resolved whether it's the required type or not. The scale of type checking is up to you.")]),t._v(" "),e("p",[t._v("The "),e("code",[t._v("__state")]),t._v(" attribute is an artificially added attribute for internal purposes. However, you may reassign it manually if you need to override the state programmatically. See "),e("a",{attrs:{href:"/guide/internal-node-attributes"}},[t._v("additional node attributes")]),t._v(" for details.")]),t._v(" "),e("p",[e("strong",[t._v("Note about ES6 classes")]),t._v("\nBeware that you cannot use classes that would implement the "),e("code",[t._v("handleNode")]),t._v(" method. The methods in classes exist only on their prototype and as such cannot be serialized and passed to the service workers. See this "),e("a",{attrs:{href:"https://localazy.com/blog/how-to-pass-function-to-web-workers",target:"_blank",rel:"noopener noreferrer"}},[t._v("blog post"),e("OutboundLink")],1),t._v(" for a more details.")]),t._v(" "),e("h2",{attrs:{id:"registering-node-evaluator"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#registering-node-evaluator"}},[t._v("#")]),t._v(" Registering node evaluator")]),t._v(" "),e("p",[t._v("Once created, you need to add node evaluators to the tree "),e("a",{attrs:{href:"/guide/options"}},[t._v("options")]),t._v(".")]),t._v(" "),e("div",{staticClass:"language-javascript extra-class"},[e("pre",{pre:!0,attrs:{class:"language-javascript"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" ExpandAllEvaluator "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("'./expand-all-evaluator'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\ncomputed"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("options")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            nodeEvaluators"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("ExpandAllEvaluator"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n        "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n")])])]),e("p",[t._v("You may add as many evaluators as you want, but beware that they are executed in order.\nOnce the "),e("a",{attrs:{href:"/advanced/tree-observer"}},[t._v("tree traversal")]),t._v(" is triggered, each node (starting from root) is visited and evaluated in each evaluator.")])])}),[],!1,null,null,null);a.default=n.exports}}]);